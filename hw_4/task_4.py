"""
Задание 4.

Приведены два алгоритма. В них определяется число,
которое встречается в массиве чаще всего.

Сделайте профилировку каждого алгоритма через timeit

Попытайтесь написать третью версию, которая будет самой быстрой и по возможности самой лаконичной.
Сделайте замеры и опишите, получилось ли у вас ускорить задачу.

Без аналитики задание считается не принятым!
"""
import timeit
import random

array = [1, 3, 1, 3, 4, 5, 1]
arr_2 = [random.randint(1, 9) for i in range(50)]


def func_1(array):
    """Для короткого вписка достаточно быстрый вариант по измерениям. Неоптимально то, что для каждого последующего вновь встреченного
элемента заново считается count() Сложность больше O(n)
Для ф-ции count() табличной сложности не указано, очевидно она требует прохода по массиву, то есть O(n)
Получается на каждой итерации O(n) итого сложность O(n^2)"""
    m = 0
    num = 0
    for i in array:
        count = array.count(i)
        if count > m:
            m = count
            num = i
    return f'Чаще всего встречается число {num}, ' \
           f'оно появилось в массиве {m} раз(а)'


def func_2(array):
    """Достаточно медленный вариант, один проход по циклу для создания нового
    массива применяя встроенные ф-ции, затем на новый массив встроенные
    ф-ции max() index() Сложность O(n^2) на первый проход, и еще по O(m) (m < n) на max() и index()"""
    new_array = []
    for el in array:
        count2 = array.count(el)
        new_array.append(count2)

    max_2 = max(new_array)
    elem = array[new_array.index(max_2)]
    return f'Чаще всего встречается число {elem}, ' \
           f'оно появилось в массиве {max_2} раз(а)'


def func_3(array):
    """Предложенная ф-ция, вариант 1. Оптимизированный. Для короткого списка не оптимальный
     по замерам (при запусках чуть хуже func_1),
    но для более длинных списков работает быстрее, чем ф-ции 1 и 2.
    В рамках одного цикла создаем словарь и проверяем значение на максимальность.
    Проходим один раз, получение значения из словаря O(1) соответственно,
    сложность ~O(n)"""
    dct = {}
    key = None
    val = 0
    for el in array:
        a = dct.get(el)
        if a is None:
            dct[el] = 1
        else:
            dct[el] += 1
        if val < dct[el]:
            val = dct[el]
            key = el
    return f'Чаще всего встречается число {key}, ' \
           f'оно появилось в массиве {val} раз(а)'


def func_4(array):
    """Предложенная ф-ция, вариант 2. Оптимизированный.
    Доработка ф-ции 1, убираем повторные вычисления count() итерируя не по исходному массиву,
    а делаем из него множество.
    Проходим один раз и на каждом проходе count() дает сложность O(n), соответственно,
    сложность O(m * n) где m - кол-во уникальных значений.
    Если m => n то сложность стремится к O(n^2). Но для небольших m работает быстро,
    поскольку проходит только по уникальным элементам"""
    m = 0
    num = 0
    for i in set(array):
        count = array.count(i)
        if count > m:
            m = count
            num = i
    return f'Чаще всего встречается число {num}, ' \
           f'оно появилось в массиве {m} раз(а)'



print(func_1(array))
print(func_2(array))
print(func_3(array))
print(func_4(array))


for i in range(1, 5):
    print(
        f"время выполнения ф-ции {i} составило {timeit.timeit(stmt=f'func_{i}(array)', setup=f'from __main__ import func_{i}, array')}")

for i in range(1, 5):
    print(
        f"время выполнения ф-ции {i} составило {timeit.timeit(stmt=f'func_{i}(arr_2)', setup=f'from __main__ import func_{i}, arr_2')}")

"""Результат. Для большей наглядности, модифицировал код и измерил на коротком и длинном списке.
Видно, что на длинном списке оба предложенных варианта являются оптимизированными.

Чаще всего встречается число 1, оно появилось в массиве 3 раз(а)
Чаще всего встречается число 1, оно появилось в массиве 3 раз(а)
Чаще всего встречается число 1, оно появилось в массиве 3 раз(а)
Чаще всего встречается число 1, оно появилось в массиве 3 раз(а)
время выполнения ф-ции 1 составило 1.8289087000000002
время выполнения ф-ции 2 составило 2.4208418000000007
время выполнения ф-ции 3 составило 2.1573561999999997
время выполнения ф-ции 4 составило 1.6629557000000004
время выполнения ф-ции 1 составило 39.6702311
время выполнения ф-ции 2 составило 43.023165799999994
время выполнения ф-ции 3 составило 11.98677099999999
время выполнения ф-ции 4 составило 8.256349400000005

"""
