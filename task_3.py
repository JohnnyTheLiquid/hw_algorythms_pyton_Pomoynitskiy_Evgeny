"""
Задание 3.

Для этой задачи:
1) придумайте 2-3 решения (не менее двух) разной!! сложности
2) оцените сложность каждого решения в нотации О-большое
3) сделайте вывод, какое решение эффективнее и почему

Сама задача:
Имеется хранилище с информацией о компаниях: название и годовая прибыль.
Для реализации хранилища можно применить любой подход,
который вы придумаете, например, реализовать словарь.
Реализуйте поиск трех компаний с наибольшей годовой прибылью.
Выведите результат.

Примечание:
Без выполнения пунктов 2 и 3 задание считается нерешенным. Пункты 2 и 3 можно выполнить
через строки документации в самом коде.
Прошу вас внимательно читать ТЗ и не забыть выполнить все пункты.

Задание творческое. Здесь нет жестких требований к выполнению.
"""
db_dict = {'a': 200, 'b': 100, 'c': 4000, 'd': 1000, 'e': 250, 'f': -10000, 'g': 500}


def find_max_1(dict_obj):
    """Принимает на вход словарь, где ключ - название компании, значение - прибыль.
    Выводит 3 максимальных значения, определяя максимум и последовательно убирает эти элементы
    Сложность ~ O(n)"""
    res_dict = {}

    for i in range(3):  # 3*O(1)
        max_income = 0
        for key, val in dict_obj.items():  # O(n)
            if val >= max_income:
                max_income = val

        key_max = list(dict_obj.keys())[0]
        for key, val in dict_obj.items():  # O(n)
            if val == max_income:
                res_dict[key] = val
                key_max = key

        del dict_obj[key_max]

    return res_dict


def find_max_2(dict_obj):
    """Принимает на вход словарь, где ключ - название компании, значение - прибыль.
    Выводит 3 максимальных значения, определяя максимум через сравнение всех со всеми
    и последовательно убирает эти элементы
    Сложность O(n^2)"""
    res_dict = {}
    for i in range(3):  # 3*O(1)
        max_income = 0
        for val1 in dict_obj.values():  # O(n)
            max_income = val1
            for val2 in dict_obj.values():  # O(n)
                if val2 > max_income:
                    max_income = val2

        key_max = list(dict_obj.keys())[0]
        for key, val in dict_obj.items():  # O(n)
            if val == max_income:
                res_dict[key] = val
                key_max = key

        del dict_obj[key_max]

    return res_dict


print(find_max_1(db_dict), '\n')
db_dict = {'a': 200, 'b': 100, 'c': 4000, 'd': 1000, 'e': 250, 'f': -10000, 'g': 500}
print(find_max_2(db_dict))

""" Не пойму, в чем подвох. Если запускать вывод обеих ф-ций сразу, то срабатывает 
последовательное применение, т.е., первая берет 3 самых больших, а вторая следующие 
3 самых больших. Если заглушить первый принт, вторая ф-ция работает корректно. 
Пока не понял, в чем косяк. Как может вызов ф-ции изменить словарь с данными...
 В качестве костыля заново определил словарь"""

""" Первая функция более эффективна, как линейно зависящая от n
У второй зависимость квадратичная, растет быстрее с возрастанием n """
